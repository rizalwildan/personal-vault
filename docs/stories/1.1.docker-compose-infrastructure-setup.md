# Story 1.1: Docker Compose Infrastructure Setup

## Status

**Approved**

---

## Story

**As a** developer setting up BMad-Personal-Vault for the first time,
**I want** a Docker Compose configuration that starts PostgreSQL with pgvector, frontend, and backend services,
**so that** I can have a complete working development environment without manual configuration.

---

## Acceptance Criteria

1. `docker-compose up` starts all 3 services without errors
2. PostgreSQL accessible at `localhost:5432` with pgvector enabled
3. Frontend accessible at `localhost:3000` (existing Next.js app)
4. Backend placeholder accessible at `localhost:8000`
5. All services restart automatically on failure
6. Database data persists across restarts (volume mounted)

---

## Tasks / Subtasks

- [ ] **Task 1: Create Docker Compose configuration file** (AC: 1, 2, 4, 5, 6)
  - [ ] Create `docker-compose.yml` at project root
  - [ ] Configure PostgreSQL service using `pgvector/pgvector:pg16` image
  - [ ] Set up environment variables for PostgreSQL (user, password, database name)
  - [ ] Configure health check for PostgreSQL using `pg_isready`
  - [ ] Create named volume `postgres_data` for data persistence
  - [ ] Configure restart policy: `restart: unless-stopped` for all services
  - [ ] Verify default Docker network enables service communication (Docker Compose creates this automatically)

- [ ] **Task 2: Configure PostgreSQL with pgvector extension** (AC: 2)
  - [ ] Use official `pgvector/pgvector:pg16` Docker image
  - [ ] Expose port 5432 to host
  - [ ] Set database name to `personal_vault`
  - [ ] Configure volume mount for data persistence at `/var/lib/postgresql/data`
  - [ ] Add health check with 10s interval, 5s timeout, 5 retries

- [ ] **Task 3: Configure frontend service** (AC: 3)
  - [ ] Add frontend service using Node.js base image (`node:20-alpine`)
  - [ ] Configure volume mounts: `./frontend:/app` and anonymous volume `/app/node_modules` for performance
  - [ ] Set working directory to `/app` and command to `npm run dev`
  - [ ] Expose port 3000 to host
  - [ ] Set environment variable `NEXT_PUBLIC_API_URL=http://localhost:8000/api/v1`
  - [ ] Add dependency on backend service
  - [ ] Configure restart policy

- [ ] **Task 4: Configure backend placeholder service** (AC: 4)
  - [ ] Create `backend/Dockerfile` using `oven/bun:1` as base image
  - [ ] Create `backend/src/index.ts` with minimal Elysia.js hello-world endpoint at `/`
  - [ ] Create `backend/package.json` with Elysia dependency
  - [ ] Add backend service to docker-compose.yml with build context `./backend`
  - [ ] Expose port 8000 to host
  - [ ] Set environment variable `DATABASE_URL=postgresql://postgres:postgres@postgres:5432/personal_vault`
  - [ ] Add dependency on PostgreSQL service (wait for health check)
  - [ ] Configure restart policy

- [ ] **Task 5: Create environment configuration files** (AC: 1)
  - [ ] Create `backend/.env.example` with backend-specific variables (DATABASE_URL, JWT_SECRET, PORT, etc.)
  - [ ] Create `frontend/.env.local.example` with frontend-specific variables (NEXT_PUBLIC_API_URL)
  - [ ] Document DATABASE_URL format (use service name `postgres` for Docker context)
  - [ ] Document JWT_SECRET placeholder with security warning
  - [ ] Add inline comments explaining each variable
  - [ ] Note: Developers copy these to `backend/.env` and `frontend/.env.local` respectively

- [ ] **Task 6: Test Docker Compose configuration** (AC: 1, 2, 3, 4, 5, 6)
  - [ ] Run `docker-compose up` and verify all services start
  - [ ] Test PostgreSQL connection: `psql -h localhost -U postgres -d personal_vault`
  - [ ] Verify pgvector extension: `SELECT * FROM pg_extension WHERE extname = 'vector';`
  - [ ] Verify frontend accessible at http://localhost:3000
  - [ ] Verify backend placeholder at http://localhost:8000
  - [ ] Test service restart: kill a container and verify auto-restart
  - [ ] Test data persistence: restart services and verify data survives

---

## Dev Notes

### Previous Story Insights
No previous story exists. This is Story 1.1 - the foundation of the project.

### Docker Compose Configuration
[Source: architecture/development-workflow.md#docker-compose-development]

**PostgreSQL Service:**
- **Image**: `pgvector/pgvector:pg16` (official pgvector image with PostgreSQL 16)
- **Container Name**: `personal_vault_db`
- **Environment Variables**:
  - `POSTGRES_USER=postgres`
  - `POSTGRES_PASSWORD=postgres`
  - `POSTGRES_DB=personal_vault`
- **Ports**: `5432:5432`
- **Volume**: `postgres_data:/var/lib/postgresql/data`
- **Health Check**:
  ```yaml
  test: ['CMD-SHELL', 'pg_isready -U postgres']
  interval: 10s
  timeout: 5s
  retries: 5
  ```

**Network Configuration:**
Docker Compose automatically creates a default network where services can communicate using service names as hostnames (e.g., backend can connect to `postgres:5432`).

**Restart Policy:**
Use `restart: unless-stopped` for all services to ensure they restart on failure but not after manual stop.

### Database Configuration
[Source: architecture/database-schema.md#prerequisites]

**Required PostgreSQL Extensions:**
```sql
-- Enable pgvector extension for vector similarity search
CREATE EXTENSION IF NOT EXISTS vector;

-- Enable UUID generation
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
```

These extensions must be available in the database. The `pgvector/pgvector:pg16` image includes pgvector by default.

**Database Name**: `personal_vault`
**Default Credentials** (development only):
- User: `postgres`
- Password: `postgres`

[Source: architecture/development-workflow.md#local-development-setup]

### Backend Placeholder Configuration
[Source: architecture/backend-architecture.md#application-entry-point, architecture/backend-architecture.md#elysia-app-configuration]

**Technology Stack:**
- **Runtime**: Bun 1.x
- **Framework**: Elysia.js (latest)
- **Port**: 8000

**Minimal Backend Placeholder** (for Story 1.1 only, will be expanded in Story 3):
```typescript
// backend/src/index.ts
import { Elysia } from 'elysia';

const app = new Elysia()
  .get('/', () => ({ message: 'BMad Personal Vault API' }))
  .listen(8000);

console.log(`ü¶ä Elysia is running at ${app.server?.hostname}:${app.server?.port}`);
```

**Required Environment Variables:**
- `DATABASE_URL`: Connection string for PostgreSQL
- `PORT`: Server port (default: 8000)
- `FRONTEND_URL`: Frontend URL for CORS (http://localhost:3000)

[Source: architecture/development-workflow.md#environment-variables]

### Frontend Configuration
[Source: architecture/tech-stack.md#technology-stack-table]

**Technology Stack:**
- **Framework**: Next.js 16.1.6
- **Runtime**: React 19.2.3
- **Port**: 3000

**Environment Variables:**
- `NEXT_PUBLIC_API_URL`: Backend API URL (http://localhost:8000/api/v1)

The frontend already exists (shadcn/ui components implemented). This story only configures Docker Compose to run it.

### Project Structure Reference
[Source: architecture/unified-project-structure.md#workspace-configuration]

```
personal-vault/
‚îú‚îÄ‚îÄ frontend/                     # Next.js application (already exists)
‚îÇ   ‚îî‚îÄ‚îÄ .env.local.example        # THIS STORY CREATES THIS FILE
‚îú‚îÄ‚îÄ backend/                      # Elysia.js application (placeholder for now)
‚îÇ   ‚îú‚îÄ‚îÄ .env.example              # THIS STORY CREATES THIS FILE
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile                # THIS STORY CREATES THIS FILE
‚îÇ   ‚îî‚îÄ‚îÄ src/index.ts              # THIS STORY CREATES THIS FILE
‚îú‚îÄ‚îÄ shared/                       # Shared TypeScript code (Story 2)
‚îú‚îÄ‚îÄ docker-compose.yml            # THIS STORY CREATES THIS FILE
‚îî‚îÄ‚îÄ README.md
```

### File Locations
**Files to Create:**
1. `docker-compose.yml` - Root of project
2. `backend/.env.example` - Backend environment variables template
3. `frontend/.env.local.example` - Frontend environment variables template
4. `backend/Dockerfile` - Temporary Dockerfile for placeholder
5. `backend/src/index.ts` - Minimal Elysia app (if not exists)
6. `backend/package.json` - Bun project config (if not exists)

### Environment Variables Template
[Source: architecture/development-workflow.md#environment-variables]

**Backend Environment Variables** (`backend/.env.example`):
```bash
# backend/.env.example

# PostgreSQL Configuration
# IMPORTANT: Use 'postgres' as hostname when backend runs in Docker (service name)
# Use 'localhost' only if running backend natively outside Docker
DATABASE_URL=postgresql://postgres:postgres@postgres:5432/personal_vault

# Backend Server Configuration
PORT=8000
NODE_ENV=development

# CORS Configuration
FRONTEND_URL=http://localhost:3000

# JWT Authentication (CHANGE IN PRODUCTION!)
JWT_SECRET=your-secret-key-change-in-production
JWT_ACCESS_EXPIRY=1h
JWT_REFRESH_EXPIRY=30d
```

**Frontend Environment Variables** (`frontend/.env.local.example`):
```bash
# frontend/.env.local.example

# Backend API URL
NEXT_PUBLIC_API_URL=http://localhost:8000/api/v1
```

**Security Notes:**
- ‚ö†Ô∏è **DO NOT** use default credentials (`postgres/postgres`) in production
- ‚ö†Ô∏è **DO NOT** commit `.env` or `.env.local` files to git (add to `.gitignore`)
- ‚ö†Ô∏è Change `JWT_SECRET` to a strong random string in production
- üîí Production deployments require strong passwords and secrets rotation

### Technical Constraints
[Source: architecture/tech-stack.md#technology-stack-table]

**Version Requirements:**
- Docker: 24+
- Docker Compose: 2.x
- PostgreSQL: 16+
- pgvector: 0.6.0+
- Bun: 1.x

**Platform Support:**
The setup must work on macOS, Linux, and Windows WSL2.

### Testing

[Source: architecture/testing-strategy.md#backend-testing]

**Integration Tests Location**: `backend/tests/integration/`

**Test Framework**: Bun Test (built-in)

**Test Requirements for This Story:**
Since this story creates infrastructure only (no business logic), testing is primarily manual verification:

1. **Service Start Test**: Verify all services start without errors
2. **Database Connection Test**: Connect to PostgreSQL and verify pgvector extension
3. **Frontend Access Test**: Verify frontend loads at http://localhost:3000
4. **Backend Access Test**: Verify backend responds at http://localhost:8000
5. **Restart Test**: Kill containers and verify auto-restart works
6. **Persistence Test**: Create data, restart services, verify data persists

**No automated test files required for this story** - Epic 2 and 3 will add unit/integration tests when implementing business logic.

**Manual Testing Commands:**
```bash
# Start all services
docker-compose up -d

# Check service status
docker-compose ps

# Test PostgreSQL connection
docker-compose exec postgres psql -U postgres -d personal_vault -c "SELECT * FROM pg_extension WHERE extname = 'vector';"

# Test frontend
curl http://localhost:3000

# Test backend
curl http://localhost:8000

# View logs
docker-compose logs -f

# Test restart
docker-compose restart postgres
docker-compose ps  # Verify it's running again

# Clean up
docker-compose down
docker-compose down -v  # Remove volumes
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-17 | 1.0 | Initial story creation | Bob (Scrum Master) |
| 2026-02-17 | 1.1 | PO validation fixes: PostgreSQL port 5433‚Üí5432, split env files, clarify Docker config, add security notes | Sarah (Product Owner) |

---

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent during implementation_

### Debug Log References
_To be filled by dev agent during implementation_

### Completion Notes
_To be filled by dev agent during implementation_

### File List
_To be filled by dev agent during implementation_

---

## QA Results

_To be filled by QA agent after story completion_
