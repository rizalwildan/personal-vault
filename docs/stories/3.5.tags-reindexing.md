# Story 3.5: Tags Management and Manual Re-indexing

**Status:** Draft

**Epic:** Epic 3 - Backend Notes CRUD & Embedding Generation

---

## Story

**As a** frontend developer,
**I want** to manage tags for organizing notes and manually trigger re-indexing of failed embeddings,
**so that** users can organize their knowledge base and recover from embedding generation failures.

---

## Acceptance Criteria

- [ ] GET /api/v1/tags returns list of user's tags (200 OK)
- [ ] GET /api/v1/tags sorts tags alphabetically by name
- [ ] GET /api/v1/tags returns tags array with id, name, color, created_at
- [ ] POST /api/v1/tags creates new tag (201 Created)
- [ ] POST /api/v1/tags validates tag name uniqueness per user (no duplicates)
- [ ] POST /api/v1/tags validates color format if provided (#RRGGBB hex)
- [ ] POST /api/v1/tags returns 409 Conflict if tag name already exists for user
- [ ] POST /api/v1/tags returns 400 Bad Request for validation errors
- [ ] PATCH /api/v1/tags/:id updates tag name and/or color
- [ ] PATCH /api/v1/tags/:id validates uniqueness after rename (can't rename to duplicate)
- [ ] PATCH /api/v1/tags/:id returns 404 Not Found if tag doesn't exist or doesn't belong to user
- [ ] PATCH /api/v1/tags/:id returns 409 Conflict if new name already exists
- [ ] DELETE /api/v1/tags/:id deletes tag and removes from all notes
- [ ] DELETE /api/v1/tags/:id returns 200 OK with success: true, data: null
- [ ] DELETE /api/v1/tags/:id returns 404 Not Found if tag doesn't exist or doesn't belong to user
- [ ] DELETE /api/v1/tags/:id cascade removes tag from all notes using that tag
- [ ] POST /api/v1/notes/reindex queues all user's notes for re-indexing (200 OK)
- [ ] POST /api/v1/notes/reindex marks all notes with embedding_status='pending'
- [ ] POST /api/v1/notes/reindex enqueues all notes for embedding generation
- [ ] POST /api/v1/notes/reindex returns queued_count of notes queued
- [ ] All five endpoints require JWT authentication
- [ ] All endpoints check user ownership (user can only manage own tags)
- [ ] TagsService handles all business logic
- [ ] TagsRepository handles all data access
- [ ] Response formats follow standard: { success: true, data: {...} } or { success: false, error: {...} }
- [ ] Unit tests for tag uniqueness validation
- [ ] Integration tests for all tag CRUD operations
- [ ] Integration tests for tag cascade deletion (verify removed from notes)
- [ ] Integration tests for re-indexing (verify all notes queued)

---

## Tasks / Subtasks

- [ ] Task 1: Create Tags Repository (AC: 22, 23)
  - [ ] Create `backend/src/repositories/tags.repository.ts` file
  - [ ] Implement `findByUserAndId(userId, tagId)` - Get tag with ownership check
  - [ ] Implement `create(userId, name, color)` - Create new tag
    - [ ] Must check uniqueness first (use query to verify no duplicate)
    - [ ] If exists, return null or throw (handle in service)
    - [ ] Insert and return tag
  - [ ] Implement `list(userId)` - Get all user's tags sorted by name
    - [ ] Query: SELECT \* FROM tags WHERE user_id=$1 ORDER BY name ASC
  - [ ] Implement `update(tagId, userId, updates)` - Update tag with ownership check
    - [ ] Query with WHERE id=$1 AND user_id=$2
    - [ ] Update and return
    - [ ] If not found, return null
  - [ ] Implement `delete(tagId)` - Delete tag
    - [ ] Query: DELETE FROM tags WHERE id=$1
    - [ ] Cascade handled by database trigger/constraint
  - [ ] Implement `removeTagFromNotes(userId, tagId)` - Remove tag from all notes
    - [ ] Query all notes with this tag: WHERE user_id=$1 AND tags @> ARRAY[tagName]
    - [ ] Update tags array for each note: Remove tagName from text[] array
    - [ ] Use Drizzle array operations: `array_remove(tags, $tagName)`
    - [ ] Return count of updated notes
  - [ ] Implement `findByName(userId, name)` - Check if tag exists by name
    - [ ] Query: SELECT id FROM tags WHERE user_id=$1 AND name=$2
    - [ ] Used for uniqueness validation before create

- [ ] Task 2: Create Tags Service (AC: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 22, 23)
  - [ ] Create `backend/src/services/tags.service.ts` file
  - [ ] Define TagsService class with dependency injection: constructor receives repository
  - [ ] Import shared schemas: CreateTagSchema, UpdateTagSchema, TagSchema
  - [ ] Implement `list(userId)` async method
    - [ ] Call: repository.list(userId)
    - [ ] Return sorted tags array
  - [ ] Implement `create(userId, input)` async method
    - [ ] Validate input with CreateTagSchema
    - [ ] Check uniqueness: `repository.findByName(userId, input.name)`
    - [ ] If exists, throw ConflictError('Tag name already exists')
    - [ ] Call: repository.create(userId, input.name, input.color)
    - [ ] Return created tag
  - [ ] Implement `update(tagId, userId, input)` async method
    - [ ] Validate input with UpdateTagSchema
    - [ ] Fetch existing tag: `repository.findByUserAndId(userId, tagId)`
    - [ ] If not found, throw NotFoundError('Tag')
    - [ ] If name changed, check uniqueness
    - [ ] Call: repository.update(tagId, userId, input)
    - [ ] Return updated tag
  - [ ] Implement `delete(tagId, userId)` async method
    - [ ] Fetch tag: `repository.findByUserAndId(userId, tagId)`
    - [ ] If not found, throw NotFoundError('Tag')
    - [ ] Get tag name for cascade delete
    - [ ] Remove from all notes: `repository.removeTagFromNotes(userId, tagId)`
    - [ ] Delete tag: `repository.delete(tagId)`
    - [ ] Return null (for API response)
  - [ ] Create singleton export: `export const tagsService = new TagsService(tagsRepository)`

- [ ] Task 3: Create Tags Routes (AC: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 20)
  - [ ] Create `backend/src/routes/tags.routes.ts` file
  - [ ] Import Elysia and validation: `import { Elysia, t } from 'elysia'`
  - [ ] Import authMiddleware, tagsService
  - [ ] Import Zod schemas: CreateTagSchema, UpdateTagSchema
  - [ ] Create Elysia route group: `new Elysia({ prefix: '/tags' }).use(authMiddleware)`
  - [ ] Implement GET / endpoint
    - [ ] Handler: async ({ user }) => { ... }
    - [ ] Call: tagsService.list(user.id)
    - [ ] Return: { success: true, data: { tags: [...] } }
    - [ ] Response status: 200
  - [ ] Implement POST / endpoint
    - [ ] Handler: async ({ user, body }) => { ... }
    - [ ] Call: tagsService.create(user.id, body)
    - [ ] Return: { success: true, data: tag }
    - [ ] Response status: 201 Created
    - [ ] Body validation: CreateTagSchema
    - [ ] Error handling: ConflictError → 409, ValidationError → 400
  - [ ] Implement PATCH /:id endpoint
    - [ ] Handler: async ({ user, params, body }) => { ... }
    - [ ] Call: tagsService.update(params.id, user.id, body)
    - [ ] Return: { success: true, data: tag }
    - [ ] Response status: 200
    - [ ] Body validation: UpdateTagSchema (partial)
    - [ ] Error handling: ConflictError → 409, NotFoundError → 404
  - [ ] Implement DELETE /:id endpoint
    - [ ] Handler: async ({ user, params }) => { ... }
    - [ ] Call: tagsService.delete(params.id, user.id)
    - [ ] Return: { success: true, data: null }
    - [ ] Response status: 200
  - [ ] Swagger documentation tags: detail: { tags: ['tags'] }

- [ ] Task 4: Create Re-indexing Route in Notes Routes (AC: 17, 18, 19, 20)
  - [ ] Add POST /api/v1/notes/reindex endpoint to notes.routes.ts
  - [ ] Handler: async ({ user }) => { ... }
  - [ ] Implement reindex logic:
    - [ ] Fetch all user's notes: repository.list(user.id, { limit: 9999 })
      - [ ] Or: SELECT \* FROM notes WHERE user_id=$1
    - [ ] For each note:
      - [ ] Mark embedding_status='pending'
      - [ ] Queue embedding: embeddingQueue.enqueue(noteId)
    - [ ] Track queued_count
  - [ ] Return:
    ```typescript
    {
      success: true,
      data: {
        message: 'Re-indexing started',
        queued_count: number
      }
    }
    ```
  - [ ] Response status: 200

- [ ] Task 5: Create Zod Schemas for Tags (AC: shared concern, validation)
  - [ ] Verify schemas exist in `shared/schemas/tags.ts`
  - [ ] If not, create with:
    - [ ] `CreateTagSchema`: name (required, 1-50 chars), color (optional, hex format)
    - [ ] `UpdateTagSchema`: Partial of CreateTagSchema
    - [ ] `TagSchema`: Full tag object (id, user_id, name, color, created_at)
  - [ ] Hex color validation: z.string().regex(/^#[0-9A-Fa-f]{6}$/)
  - [ ] Tag name: z.string().min(1).max(50)

- [ ] Task 6: Create Tags Repository Database Queries (AC: detailed DB operations)
  - [ ] Use Drizzle ORM for all queries
  - [ ] Example CREATE query:
    ```typescript
    const [tag] = await db
      .insert(tags)
      .values({ user_id: userId, name, color })
      .returning();
    return tag;
    ```
  - [ ] Example LIST query:
    ```typescript
    const userTags = await db
      .select()
      .from(tags)
      .where(eq(tags.user_id, userId))
      .orderBy(asc(tags.name));
    return userTags;
    ```
  - [ ] Example UPDATE query:
    ```typescript
    const [updated] = await db
      .update(tags)
      .set({ ...updates })
      .where(and(eq(tags.id, tagId), eq(tags.user_id, userId)))
      .returning();
    return updated || null;
    ```
  - [ ] Example REMOVE FROM NOTES query:

    ```typescript
    const updatedNotes = await db
      .select()
      .from(notes)
      .where(
        and(eq(notes.user_id, userId), sql`${notes.tags} @> ARRAY[${tagName}]`),
      );

    for (const note of updatedNotes) {
      const newTags = note.tags.filter((t) => t !== tagName);
      await db
        .update(notes)
        .set({ tags: newTags })
        .where(eq(notes.id, note.id));
    }
    ```

- [ ] Task 7: Unit Tests for Tag Uniqueness (AC: 28)
  - [ ] Create `backend/tests/unit/services/tags.uniqueness.test.ts`
  - [ ] Test 1: Can create first tag with name
    - [ ] User has no tags
    - [ ] Create tag 'docker'
    - [ ] Should succeed
  - [ ] Test 2: Cannot create duplicate tag name
    - [ ] User already has tag 'docker'
    - [ ] Try to create 'docker' again
    - [ ] Should throw ConflictError
  - [ ] Test 3: Same tag name allowed for different users
    - [ ] User A creates tag 'docker'
    - [ ] User B creates tag 'docker'
    - [ ] Both should succeed (no conflict)
  - [ ] Test 4: Can rename tag to different name
    - [ ] User has tag 'docker'
    - [ ] Rename to 'kubernetes'
    - [ ] Should succeed
  - [ ] Test 5: Cannot rename to duplicate
    - [ ] User has tags 'docker' and 'kubernetes'
    - [ ] Try to rename 'docker' to 'kubernetes'
    - [ ] Should throw ConflictError

- [ ] Task 8: Integration Tests for Tag CRUD (AC: 29)
  - [ ] Create `backend/tests/integration/routes/tags.crud.test.ts`
  - [ ] Setup: Create test user, cleanup after tests
  - [ ] Test 1: List tags returns empty array
    - [ ] GET /api/v1/tags for new user
    - [ ] Assert tags: []
  - [ ] Test 2: Create tag successfully
    - [ ] POST /api/v1/tags with name='docker', color='#3B82F6'
    - [ ] Assert HTTP 201
    - [ ] Assert returned tag has id, name, color, created_at
  - [ ] Test 3: List returns created tags sorted alphabetically
    - [ ] Create tags: 'kubernetes', 'docker', 'testing'
    - [ ] GET /api/v1/tags
    - [ ] Assert order: ['docker', 'kubernetes', 'testing']
  - [ ] Test 4: Cannot create duplicate tag
    - [ ] Create tag 'docker'
    - [ ] Try to create 'docker' again
    - [ ] Assert HTTP 409 Conflict
  - [ ] Test 5: Update tag name
    - [ ] Create tag 'docker'
    - [ ] PATCH /api/v1/tags/:id with name='container'
    - [ ] Assert returned tag name='container'
  - [ ] Test 6: Update tag color
    - [ ] Create tag 'docker' with color='#3B82F6'
    - [ ] PATCH /api/v1/tags/:id with color='#10B981'
    - [ ] Assert color updated
  - [ ] Test 7: Cannot rename to duplicate
    - [ ] Create tags 'docker' and 'container'
    - [ ] Try to rename 'docker' to 'container'
    - [ ] Assert HTTP 409 Conflict
  - [ ] Test 8: Delete tag
    - [ ] Create tag 'docker'
    - [ ] DELETE /api/v1/tags/:id
    - [ ] Assert HTTP 200
    - [ ] Verify tag removed from database
  - [ ] Test 9: Requires authentication
    - [ ] GET /api/v1/tags without JWT
    - [ ] Assert HTTP 401 Unauthorized

- [ ] Task 9: Integration Tests for Cascade Delete (AC: 30)
  - [ ] Create `backend/tests/integration/routes/tags.cascade.test.ts`
  - [ ] Setup: Create test user, notes, tags
  - [ ] Test 1: Delete tag removes from all notes
    - [ ] Create tag 'docker'
    - [ ] Create 3 notes with tags=['docker', 'other']
    - [ ] DELETE /api/v1/tags/:id (delete 'docker' tag)
    - [ ] Verify all 3 notes now have tags=['other'] (docker removed)
  - [ ] Test 2: Delete tag with no notes using it
    - [ ] Create tag 'unused'
    - [ ] DELETE /api/v1/tags/:id
    - [ ] Should succeed without error
    - [ ] No notes affected
  - [ ] Test 3: Delete tag doesn't affect other users' tags
    - [ ] User A creates note with tag 'docker'
    - [ ] User B creates tag 'docker'
    - [ ] User A deletes tag 'docker'
    - [ ] User B's tag 'docker' still exists

- [ ] Task 10: Integration Tests for Re-indexing (AC: 31)
  - [ ] Create `backend/tests/integration/routes/notes.reindex.test.ts`
  - [ ] Setup: Create test user with notes in various embedding states
  - [ ] Test 1: Re-index queues all notes
    - [ ] Create 5 notes
    - [ ] POST /api/v1/notes/reindex
    - [ ] Assert HTTP 200
    - [ ] Assert queued_count=5
  - [ ] Test 2: Re-index marks all notes as pending
    - [ ] Create 3 notes with various embedding_status
    - [ ] POST /api/v1/notes/reindex
    - [ ] Query database: verify all notes have embedding_status='pending'
  - [ ] Test 3: Re-index enqueues embeddings
    - [ ] Create 3 notes
    - [ ] POST /api/v1/notes/reindex
    - [ ] Verify embeddingQueue received all 3 noteIds
    - [ ] (May need to mock queue or wait for processing)
  - [ ] Test 4: Only user's notes re-indexed
    - [ ] User A: 2 notes
    - [ ] User B: 3 notes
    - [ ] User A POST /api/v1/notes/reindex
    - [ ] Assert queued_count=2 (only A's notes)
  - [ ] Test 5: Re-index with no notes
    - [ ] New user with 0 notes
    - [ ] POST /api/v1/notes/reindex
    - [ ] Assert HTTP 200
    - [ ] Assert queued_count=0
  - [ ] Test 6: Requires authentication
    - [ ] POST /api/v1/notes/reindex without JWT
    - [ ] Assert HTTP 401 Unauthorized

---

## Dev Notes

### Previous Story Context

Stories 3.1-3.4 completed:

- Database schema with notes and tags tables (Story 3.1)
- Embedding service with queue (Story 3.2)
- Post/list/read/update/delete notes endpoints (Stories 3.3-3.4)
- NotesService and NotesRepository with all CRUD methods

This story implements tags management and re-indexing capability.

### Tags Data Model

[Source: architecture/database-schema.md#tags]

**Table Definition:**

```sql
CREATE TABLE tags (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  name VARCHAR(50) NOT NULL,
  color VARCHAR(7),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  UNIQUE(user_id, name)
);
```

**Key Constraints:**

- Unique constraint on (user_id, name) - same tag name per user only
- Color is optional, hex format validation: `^#[0-9A-Fa-f]{6}$`
- Cascade delete: when user deleted, all tags deleted

**Indexes:**

- `tags_user_id_idx` - Fast lookup by user
- `tags_name_idx` - Fast lookup by name

### Tag-Note Relationship

[Source: architecture/data-models.md & database-schema.md]

**Denormalized Tags:**

- Notes.tags is PostgreSQL text[] array
- Stores tag names directly (not foreign keys)
- Allows fast filtering with @> (overlap) operator
- When tag deleted, need to remove from notes.tags array

### API Response Format

[Source: architecture/api-specification.md]

**GET /api/v1/tags (200 OK):**

```typescript
{
  success: true,
  data: {
    tags: [
      { id: string, name: string, color: string | null, created_at: string },
      ...
    ]
  }
}
```

**POST /api/v1/tags (201 Created):**
Same single tag format wrapped in data.tag

**PATCH /api/v1/tags/:id (200 OK):**
Single tag format

**DELETE /api/v1/tags/:id (200 OK):**

```typescript
{
  success: true,
  data: null
}
```

**POST /api/v1/notes/reindex (200 OK):**

```typescript
{
  success: true,
  data: {
    message: 'Re-indexing started',
    queued_count: number
  }
}
```

### Tag Uniqueness Validation

[Source: Epic 3 Story 5 requirements]

**Per-User Uniqueness:**

- Same tag name cannot exist twice for same user
- Same tag name CAN exist for different users
- Use WHERE user_id=$1 AND name=$2 query to check

**Implementation:**

```typescript
// In service, before create
const existing = await repository.findByName(userId, name);
if (existing) {
  throw new ConflictError('Tag name already exists');
}

// In service, before update if name changed
if (updates.name && updates.name !== currentTag.name) {
  const existingWithNewName = await repository.findByName(userId, updates.name);
  if (existingWithNewName) {
    throw new ConflictError('Tag name already exists');
  }
}
```

### Tag Cascade Delete

[Source: Epic 3 Story 5 requirements]

**When Tag Deleted:**

1. Find all notes belonging to user that have this tag
2. Remove tag name from notes.tags array for each note
3. Delete tag from tags table

**PostgreSQL Array Operations:**

```sql
UPDATE notes
SET tags = array_remove(tags, 'docker')
WHERE user_id = $1 AND tags @> ARRAY['docker']
```

**Drizzle Implementation:**

```typescript
const userNotes = await db
  .select()
  .from(notes)
  .where(
    and(eq(notes.user_id, userId), sql`${notes.tags} @> ARRAY[${tagName}]`),
  );

for (const note of userNotes) {
  const newTags = note.tags.filter((t) => t !== tagName);
  await db.update(notes).set({ tags: newTags }).where(eq(notes.id, note.id));
}
```

### Re-indexing Functionality

[Source: Epic 3 Story 5 requirements]

**Purpose:** Manually trigger embedding generation for all notes (recovery from failures)

**Implementation:**

1. Fetch all notes for user
2. For each note:
   - Update embedding_status='pending'
   - Call embeddingQueue.enqueue(noteId)
3. Return queued_count

**Code Pattern:**

```typescript
const userNotes = await db
  .select()
  .from(notes)
  .where(eq(notes.user_id, userId));

for (const note of userNotes) {
  await db
    .update(notes)
    .set({ embedding_status: 'pending' })
    .where(eq(notes.id, note.id));

  embeddingQueue.enqueue(note.id);
}

return {
  success: true,
  data: {
    message: 'Re-indexing started',
    queued_count: userNotes.length,
  },
};
```

### Error Handling

[Source: architecture/error-handling-strategy.md]

**Error Types:**

- `ConflictError` (409) - Tag name already exists
- `NotFoundError` (404) - Tag doesn't exist
- `ValidationError` (400) - Invalid input (color format, name length)
- `UnauthorizedError` (401) - Missing JWT

**Usage:**

```typescript
if (existingTag) {
  throw new ConflictError('Tag name already exists');
}

if (!tag) {
  throw new NotFoundError('Tag');
}

// Note: Use 404 for authorization failures (don't reveal existence)
```

### Project Structure

[Source: architecture/unified-project-structure.md]

**Files to Create:**

- `backend/src/services/tags.service.ts`
- `backend/src/repositories/tags.repository.ts`
- `backend/src/routes/tags.routes.ts`
- Update `backend/src/app.ts` to register tags routes
- Update `backend/src/routes/notes.routes.ts` to add reindex endpoint

**Testing Structure:**

- `backend/tests/unit/services/tags.uniqueness.test.ts`
- `backend/tests/integration/routes/tags.crud.test.ts`
- `backend/tests/integration/routes/tags.cascade.test.ts`
- `backend/tests/integration/routes/notes.reindex.test.ts`

### Testing Strategy

[Source: architecture/testing-strategy.md#Backend-Testing]

**Unit Tests:**

- Tag uniqueness validation logic
- Conflict detection on create/update

**Integration Tests:**

- Tag CRUD operations (create, read, update, delete)
- Cascade delete removes from notes
- Re-indexing queues all notes
- Authorization (user isolation)
- Error scenarios (409, 404, 401)

### Coding Standards

[Source: architecture/coding-standards.md]

**Naming:**

- Service: `TagsService` (class name PascalCase)
- Method: `create()`, `list()`, `delete()` (camelCase)
- File: `tags.service.ts`, `tags.repository.ts` (camelCase with suffix)

**Type Safety:**

- All methods use TypeScript types from Zod schemas
- Optional fields marked as Optional in schemas
- Return types explicit (Tag, Tag[], null, etc.)

---

## Testing

### Testing Standards

**Test File Locations:**

- Unit tests: `backend/tests/unit/services/tags.uniqueness.test.ts`
- Integration tests: `backend/tests/integration/routes/tags.crud.test.ts`
- Integration tests: `backend/tests/integration/routes/tags.cascade.test.ts`
- Integration tests: `backend/tests/integration/routes/notes.reindex.test.ts`

**Testing Frameworks:**

- Test Runner: Bun Test (built-in)
- Assertion: Bun's expect() API (Jest-compatible)

**Test Coverage Requirements:**

- Tag uniqueness per user (create, update)
- Complete tag CRUD operations
- Cascade delete behavior (tag removed from notes)
- Re-indexing queueing all notes
- Authorization and user isolation
- Error scenarios (409, 404, 401, 400)

**Critical Test Scenarios:**

1. Tag name unique per user
2. Different users can have same tag name
3. Delete tag removes from all notes
4. Re-index marks all notes pending and queues
5. Only user's tags/notes managed (isolation)
6. Proper error codes (409 for conflict, 404 for not found)

---

## Change Log

| Date       | Version | Description                                        | Author       |
| ---------- | ------- | -------------------------------------------------- | ------------ |
| 2026-02-17 | 0.1     | Initial story draft with tags CRUD and re-indexing | Scrum Master |

---

## Dev Agent Record

_This section will be populated during development_

### Agent Model Used

[To be filled by dev agent]

### Debug Log References

[To be filled by dev agent]

### Completion Notes List

[To be filled by dev agent]

### File List

[To be filled by dev agent]

---

## QA Results

_This section will be populated after QA review_

[To be filled by QA agent]
