# Story 2.2: JWT Utilities and Password Hashing

**Status:** Approved
**Priority:** High
**Estimate:** 2-3 days
**Epic:** Epic 2 — Backend Authentication System

---

## Story

**As a** backend developer,
**I want** reusable utilities for JWT token management and password hashing,
**so that** I can implement secure authentication endpoints with proper token generation, validation, and password security.

---

## Acceptance Criteria

1. Password hashing utility implemented: `hashPassword(plaintext)` returns bcrypt hash (cost factor 10)
2. Password comparison utility implemented: `comparePassword(plaintext, hash)` validates passwords correctly
3. JWT access token utility implemented: `signAccessToken(userId)` generates JWT valid for 1 hour
4. JWT refresh token utility implemented: `signRefreshToken(userId)` generates JWT valid for 30 days
5. JWT verification utility implemented: `verifyToken(token)` validates JWT signature and expiry
6. Authentication middleware implemented: extracts and validates JWT from `Authorization: Bearer <token>` header
7. All utilities have unit tests with >90% coverage
8. Environment variables configured for JWT secrets

---

## Tasks / Subtasks

- [ ] Install required dependencies (bcrypt, jsonwebtoken)
  - [ ] Add `bcrypt` to backend/package.json (or use Bun's built-in)
  - [ ] Add `jsonwebtoken` to backend/package.json
  - [ ] Run `bun install` to install dependencies
- [ ] Create password hashing utilities in `backend/src/utils/auth.ts`
  - [ ] Implement `hashPassword(plaintext: string): Promise<string>` using bcrypt cost 10
  - [ ] Implement `comparePassword(plaintext: string, hash: string): Promise<boolean>` for validation
  - [ ] Use Bun's built-in password utilities if available
- [ ] Create JWT token utilities in `backend/src/utils/auth.ts`
  - [ ] Implement `signAccessToken(userId: string): Promise<string>` - expires in 1 hour
  - [ ] Implement `signRefreshToken(userId: string): Promise<string>` - expires in 30 days
  - [ ] Implement `verifyAccessToken(token: string): Promise<JWTPayload>` - validates signature and expiry
  - [ ] Implement `verifyRefreshToken(token: string): Promise<JWTPayload>` - validates signature and expiry
  - [ ] Use HS256 algorithm with environment secrets
- [ ] Create authentication middleware in `backend/src/middleware/auth.ts`
  - [ ] Implement `authMiddleware` function that extracts JWT from Authorization header
  - [ ] Validate JWT token using `verifyAccessToken`
  - [ ] Attach userId to request context on success
  - [ ] Return 401 Unauthorized for missing/invalid tokens
- [ ] Configure environment variables
  - [ ] Add `JWT_ACCESS_SECRET` to docker-compose.yml and .env.example
  - [ ] Add `JWT_REFRESH_SECRET` to docker-compose.yml and .env.example
  - [ ] Generate secure random secrets (256-bit)
- [ ] Write comprehensive unit tests
  - [ ] Test password hashing and comparison (success/failure cases)
  - [ ] Test JWT signing and verification (valid/expired/invalid signature)
  - [ ] Test middleware with valid/invalid/missing tokens
  - [ ] Achieve >90% test coverage for auth utilities
  - [ ] Run tests with `bun test` to ensure passing

---

## Dev Notes

Based on specifications from tech-stack.md, backend-architecture.md, and testing-strategy.md.

### Previous Story Context

**From Story 2.1 (Database Schema for Users and Sessions):**

- Users and sessions tables fully implemented and migrated
- Zod schemas available in `/shared/schemas/user.ts` and `/shared/schemas/session.ts`
- Database connection established via `backend/src/db/client.ts`
- Drizzle ORM configured and working

### Source Tree Context

Current project structure (relevant portions):

```
personal-vault/
├── backend/
│   ├── src/
│   │   ├── utils/              # EXISTS - Directory for utilities
│   │   │   └── auth.ts         # CREATE - Authentication utilities
│   │   ├── middleware/         # EXISTS - Directory for middleware
│   │   │   └── auth.ts         # CREATE - Auth middleware
│   │   ├── db/
│   │   │   ├── client.ts       # EXISTS - Database connection
│   │   │   └── schema/         # EXISTS - Database schemas
│   │   └── routes/             # EXISTS - API routes (for future stories)
│   ├── tests/
│   │   └── unit/               # EXISTS - Unit test directory
│   │       └── utils/          # CREATE - Auth utility tests
│   ├── package.json            # EXISTS - Add dependencies here
│   ├── drizzle.config.ts       # EXISTS - Drizzle configuration
│   └── tsconfig.json           # EXISTS - TypeScript configuration
├── shared/
│   └── schemas/                # EXISTS - Zod schemas
└── docker-compose.yml          # EXISTS - Add env vars here
```

### Technical Implementation Details

**Password Hashing:**

Use Bun's built-in password utilities for optimal performance:

```typescript
// backend/src/utils/auth.ts
export async function hashPassword(password: string): Promise<string> {
  return await Bun.password.hash(password, {
    algorithm: 'bcrypt',
    cost: 10, // Industry standard cost factor
  });
}

export async function comparePassword(
  plaintext: string,
  hash: string,
): Promise<boolean> {
  return await Bun.password.verify(plaintext, hash);
}
```

**JWT Token Management:**

Use jsonwebtoken library for JWT operations, as specified in tech-stack.md:

```typescript
// backend/src/utils/auth.ts
import { sign, verify } from 'jsonwebtoken';

const ACCESS_TOKEN_SECRET = process.env.JWT_ACCESS_SECRET!;
const REFRESH_TOKEN_SECRET = process.env.JWT_REFRESH_SECRET!;

export interface JWTPayload {
  userId: string;
  type: 'access' | 'refresh';
  iat: number;
  exp: number;
}

export async function signAccessToken(userId: string): Promise<string> {
  return new Promise((resolve, reject) => {
    sign(
      { userId, type: 'access' },
      ACCESS_TOKEN_SECRET,
      { expiresIn: '1h' },
      (err, token) => {
        if (err) reject(err);
        else resolve(token!);
      },
    );
  });
}

export async function signRefreshToken(userId: string): Promise<string> {
  return new Promise((resolve, reject) => {
    sign(
      { userId, type: 'refresh' },
      REFRESH_TOKEN_SECRET,
      { expiresIn: '30d' },
      (err, token) => {
        if (err) reject(err);
        else resolve(token!);
      },
    );
  });
}

export async function verifyAccessToken(token: string): Promise<JWTPayload> {
  return new Promise((resolve, reject) => {
    verify(token, ACCESS_TOKEN_SECRET, (err, decoded) => {
      if (err) reject(err);
      else resolve(decoded as JWTPayload);
    });
  });
}

export async function verifyRefreshToken(token: string): Promise<JWTPayload> {
  return new Promise((resolve, reject) => {
    verify(token, REFRESH_TOKEN_SECRET, (err, decoded) => {
      if (err) reject(err);
      else resolve(decoded as JWTPayload);
    });
  });
}
```

**Authentication Middleware:**

```typescript
// backend/src/middleware/auth.ts
import { verifyAccessToken } from '../utils/auth';

export const authMiddleware = async (ctx: any) => {
  const authHeader =
    ctx.request?.headers.get('authorization') || ctx.headers?.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return { error: 'Missing or invalid authorization header', status: 401 };
  }

  const token = authHeader.substring(7);

  try {
    const payload = await verifyAccessToken(token);
    return { userId: payload.userId };
  } catch (error) {
    return { error: 'Invalid or expired token', status: 401 };
  }
};
```

**Environment Variables:**

Add to `docker-compose.yml`:

```yaml
backend:
  environment:
    JWT_ACCESS_SECRET: your-256-bit-access-secret-here
    JWT_REFRESH_SECRET: your-256-bit-refresh-secret-here
```

Generate secrets using: `openssl rand -hex 32`

**Testing Strategy:**

Create comprehensive unit tests in `backend/tests/unit/utils/auth.test.ts`:

```typescript
import { describe, it, expect } from 'bun:test';
import {
  hashPassword,
  comparePassword,
  signAccessToken,
  verifyAccessToken,
} from '../../../src/utils/auth';

describe('Password Utilities', () => {
  it('should hash password correctly', async () => {
    const password = 'testPassword123';
    const hash = await hashPassword(password);
    expect(hash).toStartWith('$2b$10$'); // bcrypt format
  });

  it('should verify correct password', async () => {
    const password = 'testPassword123';
    const hash = await hashPassword(password);
    const isValid = await comparePassword(password, hash);
    expect(isValid).toBe(true);
  });

  it('should reject incorrect password', async () => {
    const password = 'testPassword123';
    const hash = await hashPassword(password);
    const isValid = await comparePassword('wrongPassword', hash);
    expect(isValid).toBe(false);
  });
});

describe('JWT Utilities', () => {
  it('should sign and verify access token', async () => {
    const userId = 'user-123';
    const token = await signAccessToken(userId);
    const payload = await verifyAccessToken(token);
    expect(payload.userId).toBe(userId);
    expect(payload.type).toBe('access');
  });

  // Additional JWT tests...
});
```

### Security Considerations

- **Secret Management:** JWT secrets must be cryptographically secure (256-bit random)
- **Token Expiry:** Access tokens expire in 1 hour to limit exposure
- **Refresh Tokens:** Stored as SHA-256 hashes in database for security
- **Password Hashing:** bcrypt with cost factor 10 provides strong protection
- **Algorithm:** HS256 for symmetric encryption with shared secrets

### Performance Considerations

- Password hashing is CPU-intensive - use async operations
- JWT verification is fast and suitable for every request
- Middleware should be lightweight to avoid API latency
- Consider caching user data in middleware if needed

### Dependencies

**Runtime Dependencies:**

- `bcrypt` - For password hashing (if not using Bun's built-in)
- `hono/jwt` - For JWT operations (already included with Hono)

**Development Dependencies:**

- `@types/bcrypt` - TypeScript types for bcrypt

### Testing

**Test Framework:** Bun Test (built-in)
**Test Location:** `backend/tests/unit/utils/auth.test.ts`
**Coverage Target:** >90% for auth utilities
**Test Types:** Unit tests for all utility functions

**Run Tests:**

```bash
cd backend && bun test
```

---

## Change Log

| Date       | Version | Description               | Author             |
| ---------- | ------- | ------------------------- | ------------------ |
| 2026-02-17 | 0.1     | Initial draft from Epic 2 | Bob (Scrum Master) |

---

## File List

**Source Files to Create:**

- `backend/src/utils/auth.ts` - JWT and password utilities
- `backend/src/middleware/auth.ts` - Authentication middleware
- `backend/tests/unit/utils/auth.test.ts` - Unit tests

**Source Files to Modify:**

- `backend/package.json` - Add bcrypt dependency
- `docker-compose.yml` - Add JWT secret environment variables

**Source Files to Verify:**

- `shared/schemas/user.ts` - Ensure RegisterSchema and LoginSchema available
- `backend/src/db/client.ts` - Database connection for future integration

---

## Dev Agent Record

**Agent Model Used:** Grok Code Fast 1

**Debug Log References:** None - draft only.

**Completion Notes List:**

- Story drafted based on Epic 2 requirements
- All acceptance criteria aligned with epic specifications
- Implementation details provided for developer handoff
- Security and performance considerations included

---

## QA Results

**Not Applicable** - Story not yet implemented.

### Recommended Status

Ready for development assignment.</content>
<parameter name="filePath">/Users/developer/NodeProject/personal-vault/docs/stories/2.2.jwt-utilities-and-password-hashing.md
