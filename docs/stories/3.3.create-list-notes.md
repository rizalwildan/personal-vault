# Story 3.3: Create and List Notes Endpoints

**Status:** Draft

**Epic:** Epic 3 - Backend Notes CRUD & Embedding Generation

---

## Story

**As a** frontend developer,
**I want** to create new notes and retrieve paginated lists of notes with filtering,
**so that** users can save their knowledge and browse it with flexible search and organization options.

---

## Acceptance Criteria

- [ ] POST /api/v1/notes endpoint implemented and protected by JWT authentication
- [ ] POST /api/v1/notes validates request body with CreateNoteSchema from Zod
- [ ] POST /api/v1/notes creates note in database immediately with status 201 Created
- [ ] POST /api/v1/notes returns complete note object with embedding_status: 'pending'
- [ ] POST /api/v1/notes enqueues embedding generation asynchronously (non-blocking)
- [ ] POST /api/v1/notes handles validation errors with 400 Bad Request (title missing, content empty, etc.)
- [ ] POST /api/v1/notes response follows standard format: { success: true, data: { note: {...} } }
- [ ] GET /api/v1/notes endpoint implemented and protected by JWT authentication
- [ ] GET /api/v1/notes supports query parameters: page, limit, tags, is_archived, sort, order
- [ ] GET /api/v1/notes default pagination: page=1, limit=20
- [ ] GET /api/v1/notes filters by tags (comma-separated, array format acceptable)
- [ ] GET /api/v1/notes filters by is_archived status (default: false for active notes)
- [ ] GET /api/v1/notes sorts by created_at or updated_at (default: created_at)
- [ ] GET /api/v1/notes sorts ascending or descending (default: descending)
- [ ] GET /api/v1/notes returns notes array with pagination metadata
- [ ] GET /api/v1/notes pagination includes: page, limit, total, total_pages
- [ ] GET /api/v1/notes maximum limit enforced (no limit > 100)
- [ ] GET /api/v1/notes returns only authenticated user's notes (user_id must match)
- [ ] GET /api/v1/notes response follows standard format: { success: true, data: { notes: [...], pagination: {...} } }
- [ ] Authorization checks prevent access to other users' notes
- [ ] SQL queries use indexes: user_id+created_at composite index for efficient list queries
- [ ] Pagination calculated correctly: total_pages = ceil(total / limit)
- [ ] Unit tests for query parameter validation and pagination logic
- [ ] Integration tests for POST /api/v1/notes (create with/without tags, embedding queue triggered)
- [ ] Integration tests for GET /api/v1/notes (pagination, filtering, sorting)
- [ ] Integration tests for authorization (user can't access other user's notes)

---

## Tasks / Subtasks

- [ ] Task 1: Create Notes Service (AC: 5, 14, 18)
  - [ ] Create `backend/src/services/notes.service.ts` file
  - [ ] Define NotesService class with dependency injection: constructor receives repository
  - [ ] Import CreateNoteSchema, UpdateNoteSchema, NoteSchema from shared schemas
  - [ ] Import embeddingQueue from queues
  - [ ] Implement `create(userId, input)` async method
    - [ ] Validate input with CreateNoteSchema
    - [ ] Create note object with user_id, title, content, tags, embedding_status='pending', is_archived=false
    - [ ] Insert into database via repository
    - [ ] Queue embedding asynchronously: `embeddingQueue.enqueue(noteId)`
    - [ ] Return created note object
  - [ ] Create singleton export: `export const notesService = new NotesService(notesRepository)`

- [ ] Task 2: Create Notes Repository (AC: 18)
  - [ ] Create `backend/src/repositories/notes.repository.ts` file
  - [ ] Define NotesRepository class with database access methods
  - [ ] Implement `create(note)` async method - Insert and return note
  - [ ] Implement `findById(noteId)` async - Get single note by ID
  - [ ] Implement `findByUserAndId(userId, noteId)` async - Get note with ownership check
  - [ ] Implement `list(userId, filters)` async method - Query with pagination
    - [ ] Parameters: userId, page, limit, tags[], is_archived, sort, order
    - [ ] Build WHERE clause: user_id=userId AND is_archived=is_archived
    - [ ] Add tag filtering if provided: tags array contains filter values
    - [ ] Apply sorting: order by (sort field) direction
    - [ ] Calculate offset: (page - 1) \* limit
    - [ ] Query total count for pagination
    - [ ] Query paginated results
    - [ ] Return: { notes: [...], total, page, limit }
  - [ ] Implement `updateEmbeddingStatus(noteId, status)` async - Update status field
  - [ ] Implement `updateEmbedding(noteId, embedding, status)` async - Store vector + status
  - [ ] Create singleton export: `export const notesRepository = new NotesRepository(db)`

- [ ] Task 3: Create Notes Routes (AC: 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 15)
  - [ ] Create `backend/src/routes/notes.routes.ts` file
  - [ ] Import Elysia and type definitions: `import { Elysia, t } from 'elysia'`
  - [ ] Import authMiddleware, notesService
  - [ ] Import Zod schemas: CreateNoteSchema, UpdateNoteSchema, NoteSchema
  - [ ] Create Elysia route group: `new Elysia({ prefix: '/notes' }).use(authMiddleware)`
  - [ ] Implement POST / endpoint
    - [ ] Handler: async ({ user, body }) => { ... }
    - [ ] Call: `notesService.create(user.id, body)`
    - [ ] Return: { success: true, data: { note: ... } }
    - [ ] Body validation: CreateNoteSchema
    - [ ] Response status: 201
    - [ ] Error handling: Wrap in try/catch, throw ValidationError if schema fails
  - [ ] Implement GET / endpoint
    - [ ] Handler: async ({ user, query }) => { ... }
    - [ ] Query parameters: page, limit, tags, is_archived, sort, order
    - [ ] Validate and normalize query: parse numbers, handle defaults
    - [ ] Call: `notesService.list(user.id, normalizedQuery)`
    - [ ] Return: { success: true, data: { notes: [...], pagination: {...} } }
    - [ ] Response status: 200
  - [ ] Query parameter validation with Elysia `t` module
    - [ ] page: Optional(t.Number()), default 1
    - [ ] limit: Optional(t.Number()), default 20, max 100
    - [ ] tags: Optional(t.Array(t.String()))
    - [ ] is_archived: Optional(t.Boolean()), default false
    - [ ] sort: Optional(t.String()), validate: 'created_at' | 'updated_at'
    - [ ] order: Optional(t.String()), validate: 'asc' | 'desc'
  - [ ] Swagger documentation tags: detail: { tags: ['notes'] }

- [ ] Task 4: Implement Pagination Logic (AC: 17, 16, 10)
  - [ ] In NotesService.list() method
  - [ ] Validate page >= 1 (throw error if page < 1)
  - [ ] Validate limit >= 1 and limit <= 100 (clamp to range)
  - [ ] Calculate offset: (page - 1) \* limit
  - [ ] Calculate total_pages: Math.ceil(total / limit)
  - [ ] Return pagination metadata: { page, limit, total, total_pages }
  - [ ] Ensure offset calculation never negative

- [ ] Task 5: Implement Tag Filtering (AC: 11)
  - [ ] In NotesRepository.list() method
  - [ ] When tags filter provided (array of strings)
  - [ ] PostgreSQL query: WHERE tags && ARRAY[...] for ANY match
    - [ ] Alternative: WHERE tags @> ARRAY[...] for ALL match (use AND semantic)
    - [ ] For MVP, use ANY match (user searches "docker" finds notes with docker or other tags)
  - [ ] Filter is optional - if not provided, no tag filtering applied
  - [ ] Multiple tags work as OR logic (find notes with any of the tags)

- [ ] Task 6: Implement Sorting and Ordering (AC: 12, 13)
  - [ ] In NotesRepository.list() method
  - [ ] Sort field validation: must be 'created_at' or 'updated_at'
  - [ ] Order validation: must be 'asc' or 'desc'
  - [ ] Default sort: created_at DESC (newest first)
  - [ ] Build ORDER BY clause: `ORDER BY ${sortField} ${orderDirection}`
  - [ ] Apply sorting before pagination (query must order BEFORE limiting)

- [ ] Task 7: Implement Authorization Checks (AC: 18)
  - [ ] In NotesService and routes
  - [ ] POST /notes: No special check needed (creating user's own note)
  - [ ] GET /notes: Filter by user_id in query (only return user's notes)
  - [ ] Verify user.id matches in ListRequest
  - [ ] Throw UnauthorizedError if user tries to access other user's data
  - [ ] No explicit endpoint needed to fetch other users' notes (filtered at query level)

- [ ] Task 8: Implement Error Handling (AC: 6)
  - [ ] Validation errors (CreateNoteSchema fails)
    - [ ] Catch Zod validation error
    - [ ] Return 400 Bad Request with validation details
    - [ ] Error format: { success: false, error: { code: 'VALIDATION_ERROR', message: '...', details: {...} } }
  - [ ] Authorization errors (accessing other user's notes)
    - [ ] Throw UnauthorizedError if user_id mismatch
    - [ ] Return 401 Unauthorized
  - [ ] Database errors
    - [ ] Catch database exceptions
    - [ ] Log error for debugging
    - [ ] Return 500 Internal Server Error (don't expose DB details to client)

- [ ] Task 9: Unit Tests for Pagination Logic (AC: 24)
  - [ ] Create `backend/tests/unit/services/pagination.test.ts`
  - [ ] Test 1: Calculate correct total_pages
    - [ ] total=45, limit=20 → total_pages=3
    - [ ] total=50, limit=20 → total_pages=3 (wait, should be 3)
    - [ ] total=60, limit=20 → total_pages=3
  - [ ] Test 2: Calculate correct offset
    - [ ] page=1, limit=20 → offset=0
    - [ ] page=2, limit=20 → offset=20
    - [ ] page=3, limit=20 → offset=40
  - [ ] Test 3: Clamp limit to maximum
    - [ ] limit=150 → clamped to 100
    - [ ] limit=50 → remains 50
  - [ ] Test 4: Validate page >= 1
    - [ ] page=0 → error thrown
    - [ ] page=-1 → error thrown
  - [ ] Test 5: Validate limit >= 1
    - [ ] limit=0 → error thrown
    - [ ] limit=-5 → error thrown

- [ ] Task 10: Unit Tests for Query Parameter Validation (AC: 24)
  - [ ] Create `backend/tests/unit/routes/notes.query-validation.test.ts`
  - [ ] Test 1: Parse valid page and limit
    - [ ] Query: ?page=2&limit=25
    - [ ] Assert page=2, limit=25
  - [ ] Test 2: Apply defaults when not provided
    - [ ] Query: (empty)
    - [ ] Assert page=1, limit=20
  - [ ] Test 3: Parse tag filter (comma-separated)
    - [ ] Query: ?tags=docker,kubernetes
    - [ ] Assert tags=['docker', 'kubernetes']
  - [ ] Test 4: Parse is_archived filter
    - [ ] Query: ?is_archived=true
    - [ ] Assert is_archived=true
  - [ ] Test 5: Parse sort and order
    - [ ] Query: ?sort=updated_at&order=asc
    - [ ] Assert sort='updated_at', order='asc'
  - [ ] Test 6: Reject invalid sort field
    - [ ] Query: ?sort=invalid_field
    - [ ] Assert validation error thrown

- [ ] Task 11: Integration Tests for POST /notes (AC: 25)
  - [ ] Create `backend/tests/integration/routes/notes.create.test.ts`
  - [ ] Setup: Create test user, teardown after each test
  - [ ] Test 1: Create note successfully with required fields
    - [ ] POST /api/v1/notes with title and content
    - [ ] Assert HTTP 201 response
    - [ ] Assert success=true
    - [ ] Assert returned note has: id, user_id, title, content, embedding_status='pending', tags=[], is_archived=false
    - [ ] Assert timestamps (created_at, updated_at) are set
  - [ ] Test 2: Create note with tags
    - [ ] POST /api/v1/notes with title, content, tags=['docker', 'devops']
    - [ ] Assert tags stored correctly in database
    - [ ] Assert returned note includes tags
  - [ ] Test 3: Embedding queue triggered for new note
    - [ ] Create test note
    - [ ] Verify embeddingQueue.enqueue() was called with noteId
    - [ ] Can mock embeddingQueue or verify embeddings eventually processed
  - [ ] Test 4: Validation error when title missing
    - [ ] POST /api/v1/notes with content only (no title)
    - [ ] Assert HTTP 400 Bad Request
    - [ ] Assert success=false
    - [ ] Assert error contains validation message
  - [ ] Test 5: Validation error when content empty
    - [ ] POST /api/v1/notes with title and empty content=""
    - [ ] Assert HTTP 400 Bad Request
  - [ ] Test 6: Validation error when title too long
    - [ ] POST /api/v1/notes with title > 200 chars
    - [ ] Assert HTTP 400 Bad Request
  - [ ] Test 7: Requires authentication
    - [ ] POST /api/v1/notes without JWT token
    - [ ] Assert HTTP 401 Unauthorized

- [ ] Task 12: Integration Tests for GET /notes (AC: 26)
  - [ ] Create `backend/tests/integration/routes/notes.list.test.ts`
  - [ ] Setup: Create test user with 50+ notes, cleanup after tests
  - [ ] Test 1: List notes with default pagination
    - [ ] GET /api/v1/notes (no query params)
    - [ ] Assert HTTP 200
    - [ ] Assert success=true
    - [ ] Assert notes array is non-empty
    - [ ] Assert pagination metadata present: page=1, limit=20, total, total_pages
    - [ ] Assert returned 20 or fewer notes (respects limit)
  - [ ] Test 2: Pagination works correctly
    - [ ] Create 50 test notes
    - [ ] GET /api/v1/notes?page=1&limit=20
    - [ ] Assert returns notes 1-20
    - [ ] GET /api/v1/notes?page=2&limit=20
    - [ ] Assert returns notes 21-40
    - [ ] GET /api/v1/notes?page=3&limit=20
    - [ ] Assert returns notes 41-50
  - [ ] Test 3: Custom limit parameter works
    - [ ] GET /api/v1/notes?limit=10
    - [ ] Assert returns exactly 10 notes
  - [ ] Test 4: Limit capped at 100
    - [ ] GET /api/v1/notes?limit=150
    - [ ] Assert returns only 20 notes (previous default? or uses max 100?)
    - [ ] Verify actual implementation
  - [ ] Test 5: Filter by tags
    - [ ] Create notes with tags: ['docker'], ['kubernetes'], ['docker', 'devops']
    - [ ] GET /api/v1/notes?tags=docker
    - [ ] Assert returns 2 notes (both with docker tag)
  - [ ] Test 6: Filter by is_archived=false (active notes)
    - [ ] Create archived note (is_archived=true)
    - [ ] GET /api/v1/notes (default is_archived=false)
    - [ ] Assert archived notes NOT included
    - [ ] GET /api/v1/notes?is_archived=true
    - [ ] Assert only archived notes returned
  - [ ] Test 7: Sort by created_at descending (default)
    - [ ] Create 3 notes with different timestamps
    - [ ] GET /api/v1/notes?sort=created_at&order=desc
    - [ ] Assert notes returned newest first
  - [ ] Test 8: Sort by updated_at ascending
    - [ ] GET /api/v1/notes?sort=updated_at&order=asc
    - [ ] Assert notes returned oldest first
  - [ ] Test 9: User isolation (can't see other users' notes)
    - [ ] Create note for user A
    - [ ] Login as user B
    - [ ] GET /api/v1/notes as user B
    - [ ] Assert does NOT include user A's note
  - [ ] Test 10: Requires authentication
    - [ ] GET /api/v1/notes without JWT token
    - [ ] Assert HTTP 401 Unauthorized

- [ ] Task 13: Integration Tests for Authorization (AC: 27)
  - [ ] Covered by Task 12, Test 9
  - [ ] Additional edge cases:
    - [ ] Verify SQL query includes WHERE user_id = $1
    - [ ] Verify no note disclosure between users
    - [ ] Test with multiple concurrent users

---

## Dev Notes

### Previous Story Context

Stories 3.1 and 3.2 completed:

- Database schema with notes table (id, user_id, title, content, embedding_status, tags, is_archived, created_at, updated_at)
- Drizzle ORM configured with migrations applied
- Embedding service ready to generate vectors
- Embedding queue ready for async processing

This story implements the API layer to save and retrieve notes.

### API Response Format

[Source: architecture/api-specification.md#Base-Configuration & #Note-Endpoints]

**Success Response:** All note endpoints return:

```typescript
{
  success: true,
  data: {
    note: { // Single note
      id: string;
      user_id: string;
      title: string;
      content: string;
      embedding_status: 'pending' | 'processing' | 'completed' | 'failed';
      tags: string[];
      is_archived: boolean;
      created_at: string;
      updated_at: string;
    }
    // OR for list:
    notes: Array<Note>;
    pagination: {
      page: number;
      limit: number;
      total: number;
      total_pages: number;
    };
  }
}
```

**Error Response:**

```typescript
{
  success: false,
  error: {
    code: string; // 'VALIDATION_ERROR', 'UNAUTHORIZED', etc.
    message: string;
    details?: unknown; // Optional validation details
  }
}
```

### Routes Implementation Pattern

[Source: architecture/backend-architecture.md#Route-Example-Notes]

**Framework:** Elysia.js with TypeScript validation

```typescript
new Elysia({ prefix: '/notes' })
  .use(authMiddleware)
  .post('/', handler, { body: Schema, response: {...} })
  .get('/', handler, { query: QuerySchema })
```

**Key Points:**

- Routes mounted with prefix '/notes'
- All require `authMiddleware` for JWT validation
- Body/query validation with Zod schemas
- Response types defined in route config
- HTTP status codes: 201 Created for POST, 200 OK for GET
- Errors handled by middleware (error.middleware.ts)

### Service Layer Architecture

**NotesService Responsibilities:**

1. Validate input with Zod schemas
2. Call repository for database operations
3. Orchestrate related services (embeddingQueue)
4. Return domain objects to routes

**Singleton Pattern:**

```typescript
export const notesService = new NotesService(notesRepository);
```

**Order of Operations for CREATE:**

1. Validate CreateNoteSchema
2. Insert to database via repository.create()
3. Get inserted note with generated ID
4. Call embeddingQueue.enqueue(noteId) for async processing
5. Return note to client

### Repository Layer Architecture

**NotesRepository Responsibilities:**

1. Build and execute database queries
2. Handle SQL/database error mapping
3. Return raw database records

**Key Query Patterns:**

**Insert:**

```typescript
const [note] = await db
  .insert(notes)
  .values({
    user_id: userId,
    title,
    content,
    tags,
    is_archived: false,
    embedding_status: 'pending',
  })
  .returning();
return note;
```

**List with Filtering:**

```typescript
const offset = (page - 1) * limit;

// Build WHERE conditions
const conditions = [
  eq(notes.user_id, userId),
  eq(notes.is_archived, is_archived),
];

// Add tag filter if provided
if (tags?.length > 0) {
  conditions.push(
    or(...tags.map((tag) => sql`${notes.tags} @> ARRAY[${tag}]`)),
  );
}

// Query total
const [{ count }] = await db
  .select({ count: sql`COUNT(*)` })
  .from(notes)
  .where(and(...conditions));

// Query paginated results
const result = await db
  .select()
  .from(notes)
  .where(and(...conditions))
  .orderBy(sql`${sortField} ${orderDirection}`)
  .limit(limit)
  .offset(offset);

return { notes: result, total: count, page, limit };
```

### Query Parameters

[Source: architecture/api-specification.md#GET-notes]

**GET /notes Query Parameters:**

- `page`: number, default 1, min 1
- `limit`: number, default 20, max 100
- `tags`: string[], comma-separated or array format
- `is_archived`: boolean, default false (show active notes)
- `sort`: 'created_at' | 'updated_at', default 'created_at'
- `order`: 'asc' | 'desc', default 'desc'

**Validation:**

- Page >= 1 (else error)
- Limit: 1-100 (clamp to range)
- Sort field must be known column
- Order must be 'asc' or 'desc'

### Pagination Formula

```typescript
const offset = (page - 1) * limit;
const total_pages = Math.ceil(total / limit);
```

**Examples:**

- Total: 45, Limit: 20
  - Page 1: offset 0-19, total_pages 3
  - Page 2: offset 20-39, total_pages 3
  - Page 3: offset 40-44, total_pages 3

### Tag Filtering

[Source: architecture/database-schema.md#notes-tags-index]

**PostgreSQL text[] query options:**

- `@>` (contains): ALL tags must match (AND logic)
- `<@` (contained by): Tags are subset
- `&&` (overlap): ANY tag matches (OR logic)

**Implementation:**

- Use `&&` for flexible tag search (user searches "docker" finds any note mentioning docker)
- Multiple tags in filter: user searches ["docker", "kubernetes"] finds notes with either tag

### Embedding Queue Integration

**Pattern:** After note created, queue embedding asynchronously

```typescript
const note = await repository.create(...);
embeddingQueue.enqueue(note.id); // Fire and forget
return note;
```

**Important:** Do NOT await queue. Response sent immediately while embedding processes in background.

### Project Structure

[Source: architecture/unified-project-structure.md]

**Files to Create:**

- `backend/src/services/notes.service.ts` - Business logic
- `backend/src/repositories/notes.repository.ts` - Data access
- `backend/src/routes/notes.routes.ts` - HTTP handlers
- Update `backend/src/app.ts` - Register routes

**Testing Structure:**

- `backend/tests/unit/services/*.test.ts`
- `backend/tests/unit/routes/*.test.ts`
- `backend/tests/integration/routes/*.test.ts`

### Error Handling Strategy

[Source: architecture/error-handling-strategy.md]

**Error Types:**

- `ValidationError(message, details)` - 400
- `UnauthorizedError(message)` - 401
- `NotFoundError(resource)` - 404
- Catch-all for 500 errors

**Usage:**

```typescript
if (!input.title) {
  throw new ValidationError('Title is required');
}
if (note.user_id !== userId) {
  throw new UnauthorizedError();
}
```

### Authentication Context

[Source: architecture/backend-architecture.md#Authentication-Middleware]

**JWT Middleware adds to context:**

```typescript
{ user: { id: userId, email, ... } } // from JWT payload
```

**Access in routes:**

```typescript
.get('/', async ({ user, query }) => {
  // user.id available for authorization checks
})
```

### Testing Strategy

[Source: architecture/testing-strategy.md#Backend-Testing]

**Test Framework:** Bun Test (Jest-compatible)

**Unit Test Pattern:**

```typescript
test('should calculate correct total_pages', () => {
  const totalPages = Math.ceil(45 / 20);
  expect(totalPages).toBe(3);
});
```

**Integration Test Pattern:**

```typescript
test('should list user notes with pagination', async () => {
  // Setup test user and notes
  const response = await db.get('/api/v1/notes?page=1&limit=20');
  expect(response.status).toBe(200);
  expect(response.data.pagination.total).toBe(50);
});
```

### Coding Standards

[Source: architecture/coding-standards.md]

**Naming:**

- Service: `NotesService` (class name PascalCase)
- Method: `create()`, `list()` (method camelCase)
- File: `notes.service.ts` (camelCase with .service suffix)

**Validation:**

- Use Zod schemas from shared/schemas
- Validate at route level (input) and service level (output consistency)
- Throw validation errors early

**Response Pattern:**

```typescript
// Standard success
{ success: true, data: { note: {...} } }

// Pagination
{ success: true, data: { notes: [...], pagination: {...} } }
```

### No External Dependencies

- Elysia.js already installed (framework)
- Drizzle ORM already configured (Story 3.1)
- Zod schemas in shared/ (Story 3.1)
- Embedding service ready (Story 3.2)
- JWT middleware already exists

---

## Testing

### Testing Standards

**Test File Locations:**

- Unit tests: `backend/tests/unit/services/pagination.test.ts`
- Unit tests: `backend/tests/unit/routes/notes.query-validation.test.ts`
- Integration tests: `backend/tests/integration/routes/notes.create.test.ts`
- Integration tests: `backend/tests/integration/routes/notes.list.test.ts`

**Testing Frameworks:**

- Test Runner: Bun Test (built-in)
- Assertion: Bun's expect() API (Jest-compatible)

**Test Coverage Requirements:**

- Pagination calculations (offset, total_pages, clamping)
- Query parameter parsing and validation
- POST /notes endpoint (create, validation, embedding queue)
- GET /notes endpoint (list, pagination, filtering, sorting)
- Authorization checks (user isolation)
- Error handling (validation errors, auth errors)

**Critical Test Scenarios:**

1. Pagination correctness (page 1, 2, 3 return correct slices)
2. Tag filtering (single tag, multiple tags, empty tag list)
3. Sorting (created_at asc/desc, updated_at asc/desc)
4. User isolation (can't see other users' notes)
5. Embedding queue triggered on create
6. Validation errors for missing/invalid fields
7. Auth required for both endpoints

---

## Change Log

| Date       | Version | Description                                       | Author       |
| ---------- | ------- | ------------------------------------------------- | ------------ |
| 2026-02-17 | 0.1     | Initial story draft with POST/GET notes endpoints | Scrum Master |

---

## Dev Agent Record

_This section will be populated during development_

### Agent Model Used

[To be filled by dev agent]

### Debug Log References

[To be filled by dev agent]

### Completion Notes List

[To be filled by dev agent]

### File List

[To be filled by dev agent]

---

## QA Results

_This section will be populated after QA review_

[To be filled by QA agent]
